# Web Screenshot Tool v1.0

一个强大的命令行网页截图工具，可以智能截取网页内容并自动拼接为PDF文件，自动去除重复的页面结构元素。

## 🚀 功能特性

- 🖼️ **智能内容截图**：自动隐藏header、footer、导航栏等固定元素，只截取页面主要内容
- 📄 **自动PDF生成**：将截图自动拼接为PDF文件
- 🔄 **智能去重**：避免重复的页面结构，确保内容连贯
- 📏 **自适应宽度**：自动调整浏览器窗口宽度以捕获完整页面
- 🧹 **自动清理**：程序结束或中断时自动清理临时文件
- ⚡ **高效处理**：优化的截图策略，支持长页面处理
- 📊 **智能预估**：显示页面总高度和预估处理时间
- 🚫 **无限制截图**：支持任意长度的页面，无截图数量限制
- ⚡ **并行处理**：支持同时处理多个URL，大幅提升处理速度

## 安装依赖

```bash
pip install -r requirements.txt
```

## 使用方法

### 基本用法

```bash
python app.py "https://example.com"
```

### 多个网页

```bash
python app.py "https://example.com" "https://google.com" "https://github.com"
```

### 处理特殊字符

如果URL包含特殊字符（如`&`），请用引号包裹：

```bash
python app.py "https://www.google.com/search?q=test&source=hp"
```

### 处理长页面

程序会自动处理任意长度的页面：

```bash
python app.py "https://long-article-blog.com"
```

## 并行处理说明

### 性能优势
- **多线程处理**：同时处理多个URL，大幅提升效率
- **智能调度**：自动分配线程资源，避免系统过载
- **进度跟踪**：实时显示每个URL的处理状态

### 处理策略
- 最多同时处理3个URL（可调整）
- 每个URL使用独立的浏览器实例
- 自动清理临时文件和浏览器资源

## 输出示例

### 命令行输出
```
准备处理 3 个URL...
开始并行处理 3 个URL...
保存目录: /Users/sam/Desktop/web-saver

处理URL 1: https://example.com
页面总高度: 3500px, 窗口大小: 1200x1200px
预估截图数量: 4张
预估总时间: 12秒 (0.2分钟)
开始截取完整页面内容: (0-3500px)
截图 1: 位置 0/3500px, 步长 1000px
截图 2: 位置 1000/3500px, 步长 1000px
截图 3: 位置 2000/3500px, 步长 1000px
截图 4: 位置 3000/3500px, 步长 1000px
PDF文件已生成: /Users/sam/Desktop/web-saver/20240730_143022_1_Example_Domain.pdf
PDF已保存: /Users/sam/Desktop/web-saver/20240730_143022_1_Example_Domain.pdf
✅ https://example.com 处理完成

所有网页已保存为PDF: 3 个文件
处理完成！生成了 3 个PDF文件
```

## 输出文件

程序会在当前目录生成以下文件：

- `YYYYMMDD_HHMMSS_序号_页面标题.pdf` - PDF文件，文件名包含时间戳、序号和页面标题

## 技术特性

### 智能去重策略
- 自动隐藏固定定位的header、footer、导航栏等元素
- 从0像素开始截图，覆盖完整页面内容
- 使用1000px步长，确保内容连贯且无重复
- 自动计算截图数量，无限制截图张数

### 页面处理优化
- 自动检测页面实际高度，显示总像素高度
- 智能预估截图时间和数量
- 支持各种类型的网页（新闻、博客、企业网站等）
- 无高度限制，可处理任意长度的页面

### 性能优化
- 1000px步长，平衡截图质量和处理速度
- 每张截图预估3秒处理时间
- 自动清理临时文件，节省磁盘空间
- 支持Ctrl+C中断时的优雅退出

### 文件管理
- 自动清理临时截图文件
- 支持Ctrl+C中断时的文件清理
- 防止临时文件堆积

### 错误处理
- 网络超时保护
- 页面加载失败重试
- 异常情况的优雅处理

## 系统要求

- Python 3.7+
- Chrome浏览器
- 网络连接

## 依赖包

- `selenium==4.26.1` - 浏览器自动化
- `webdriver-manager==4.0.2` - Chrome驱动管理
- `pillow==11.0.0` - 图像处理

## 性能说明

### 并行处理性能
- 最多同时处理3个URL
- 每个URL独立处理，互不影响
- 总处理时间约等于最慢URL的处理时间

### 处理时间预估
- 每张截图约需3秒（包括滚动和截图时间）
- 1000px步长，确保内容连贯
- 长页面会自动计算所需截图数量

### 内存使用
- 临时截图文件会自动清理
- 支持大页面处理，但建议确保足够内存
- 并行处理会增加内存使用，建议8GB以上内存

### 文件大小
- PDF文件大小取决于页面内容和长度
- 建议确保足够磁盘空间

## 注意事项

1. **首次运行**：程序会自动下载ChromeDriver，可能需要一些时间
2. **网络连接**：确保网络连接稳定，避免截图失败
3. **内存使用**：长页面截图可能占用较多内存，并行处理时更明显
4. **文件大小**：生成的PDF文件可能较大，建议检查磁盘空间
5. **处理时间**：长页面处理时间较长，请耐心等待
6. **并发限制**：默认最多同时处理3个URL，可根据系统性能调整

## 故障排除

### 常见问题

1. **ChromeDriver下载失败**
   - 检查网络连接
   - 确保Chrome浏览器已安装

2. **截图超时**
   - 检查目标网站是否可访问
   - 尝试访问其他网站测试

3. **页面高度检测**
   - 程序会自动检测页面实际高度
   - 显示总像素高度和预估截图时间
   - 支持任意长度的页面截图

4. **临时文件未清理**
   - 程序会自动清理，如遇问题可手动删除`temp_*.png`文件

5. **长页面处理慢**
   - 这是正常现象，程序会显示预估时间
   - 可以按Ctrl+C中断处理

6. **并行处理失败**
   - 检查系统内存是否充足
   - 减少同时处理的URL数量
   - 检查网络连接稳定性

## 开发说明

### 核心功能
- `capture_full_page()` - 智能内容截图，隐藏固定元素
- `stitch_screenshots()` - 图片拼接
- `convert_to_pdf()` - PDF生成
- `process_urls_parallel()` - 并行处理多个URL

### 优化策略
- 使用JavaScript隐藏固定定位元素
- 从0像素开始截图，覆盖完整页面
- 1000px步长，平衡效率和内容连贯性
- 自动计算截图数量，智能预估处理时间
- 多线程并行处理，提升整体效率

## 版本历史

### v1.0 (当前版本) - 2024年7月30日
- ✅ **稳定发布版本**：经过全面测试的稳定版本
- ✅ **智能内容截图**：自动隐藏header、footer等固定元素
- ✅ **并行处理**：支持同时处理多个URL，大幅提升效率
- ✅ **无限制截图**：支持任意长度的页面，无截图数量限制
- ✅ **智能预估**：显示页面总高度和预估处理时间
- ✅ **自动清理**：程序结束或中断时自动清理临时文件
- ✅ **错误处理**：完善的错误处理和网络超时保护
- ✅ **命令行优化**：纯命令行版本，专注于核心功能

## 许可证

MIT License

## 贡献

欢迎提交Issue和Pull Request来改进这个工具！

## 支持

如果您遇到问题或有改进建议，请：
1. 查看故障排除部分
2. 提交Issue描述问题
3. 提供详细的错误信息和复现步骤

## 测试

运行测试脚本验证功能：

```bash
python test_command_line.py
```

测试包括：
- 单个URL处理
- 多个URL并行处理
- 无效URL处理
- 帮助信息显示
- PDF文件生成

## 下载

### v1.0 稳定版本
- **发布日期**: 2024年7月30日
- **主要特性**: 智能内容截图、并行处理、无限制截图
- **系统要求**: Python 3.7+, Chrome浏览器
- **测试状态**: ✅ 所有测试通过 (100% 成功率)

### 快速开始
```bash
# 克隆仓库
git clone https://github.com/your-username/web-saver.git
cd web-saver

# 安装依赖
pip install -r requirements.txt

# 运行测试
python test_command_line.py

# 开始使用
python app.py "https://example.com"
```
